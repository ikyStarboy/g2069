---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by 10184.
--- DateTime: 2021/1/4 20:46
---
---@class FlyTextHelper
local FlyTextHelper = T(Lib, "FlyTextHelper")

local WordSetting = {}
local FlyTaskList = {}

local FlyTextType = {
    UI = 1,
    Entity = 2,
}

local function getUITextListAndImage(text, atlas)
    local setting = WordSetting[atlas]
    if not setting then
        return {}, {}
    end
    local textList = {}
    ---字符列表
    local word = ""
    for i = 1, #text do
        word = word .. text:sub(i, i)
        if Lib.tableContain(setting.words, word) then
            if setting.folder then
                table.insert(textList, Lib.combinePath(setting.folder, word .. ".png"))
            else
                table.insert(textList, word)
            end
            word = ""
        end
    end
    return textList, setting
end

function FlyTextHelper:getUITextListAndImage(text, atlas)
    return getUITextListAndImage(text, atlas)
end

---给所有玩家发送一个屏幕飘字
---@param atlas number|string 图集标识
---@param text string 飘字内容
function FlyTextHelper:broadcastUIFlyText(text, atlas, scale)
    local packet = {
        pid = "onShowFlyText",
        type = FlyTextType.UI,
        atlas = atlas,
        text = text,
        scale = scale
    }
    WorldServer.BroadcastPacket(packet)
end

---屏幕飘字默认动画，可以重写该方法自定义动画
---@param window GUIWindow 飘字控件
---@param widthSum number 飘字的宽度
---@param maxHeight number 飘字的高度
---@param scale number 飘字的缩放
---@param setting table 飘字的配置
function FlyTextHelper:onShowUIFlyTextAnim(window, widthSum, maxHeight, scale, setting)
    local height = 30
    local width = height * (widthSum / maxHeight)
    local posX = (math.random(5, 10) * 60 + math.random(1, 100)) / 1000
    local posY = (math.random(5, 10) * 60 + math.random(1, 100)) / 1000
    window:SetArea({ posX, -width / 2 }, { posY, -height / 2 }, { 0, width * scale }, { 0, height * scale })
    local ticks = setting.duration or 20
    World.LightTimer("FlyTextHelper:onShowUIFlyTextAnim", ticks, function()
        GUIWindowManager.instance:DestroyGUIWindow(window)
    end)
end

---屏幕飘字:放大上升
---@param window GUIWindow 飘字控件
---@param widthSum number 飘字的宽度
---@param maxHeight number 飘字的高度
---@param scale number 飘字的缩放
---@param setting table 飘字的配置
function FlyTextHelper:onShowUIFlyUpTextAnim(window, widthSum, maxHeight, scale, setting)
    --print(">>>>>>>>>>>onShowUIFlyUpTextAnim",Lib.v2s(setting))
    local height = 30
    local width = height * (widthSum / maxHeight)
    local startPos = Lib.v2(50,0)
    window:SetArea({ startPos.x, -width / 2 }, { startPos.y, -height / 2 }, { 0, width * scale }, { 0, height * scale })
    window:SetHorizontalAlignment(1)
    window:SetVerticalAlignment(1)

    local actionStage = {
        [1] = {
            startScale = scale or 1,
            endScale = 1.5,
            duration = 2,
            offsetX = 0,
            offsetY = -20,
        },
        [2] = {
            startScale = 1.5,
            endScale = 1,
            duration = 3,
            offsetX = 0,
            offsetY = -5,
        },
        [3] = {
            startScale = 1,
            endScale = 1,
            duration = 6,
            offsetX = 0,
            offsetY = -2,
        },
        [4] = {
            startScale = 1,
            endScale = 0,
            duration = 6,
            offsetX = 0,
            offsetY = -2,
        }
    }

    local times = 0
    local curState = 1
    local preTime = 0
    World.LightTimer("FlyTextHelper:onShowUIFlyUpTextAnim", 1, function()
        if not actionStage[curState] then
            GUIWindowManager.instance:DestroyGUIWindow(window)
            return false
        end
        times = times + 1
        local passTime = times - preTime

        startPos = startPos + Lib.v2(actionStage[curState].offsetX, actionStage[curState].offsetY)
        --image.position = startPos

        local changeScale = passTime*(actionStage[curState].endScale - actionStage[curState].startScale)/actionStage[curState].duration
        --image.scale = actionStage[curState].startScale + changeScale
        local curScale= actionStage[curState].startScale + changeScale
        window:SetArea({ 0,startPos.x -width / 2 }, { 0,startPos.y-height / 2 }, { 0, width * curScale }, { 0, height * curScale })

        if times >= preTime + actionStage[curState].duration then
            preTime = preTime + actionStage[curState].duration
            curState = curState + 1
        end
        return true
    end)
end

---给玩家发送一个屏幕飘字
---@param target Entity 目标玩家
---@param atlas number|string 图集标识
---@param text string 飘字内容
function FlyTextHelper:onShowUIFlyText(target, atlas, text, scale)
    if World.isClient then
        local textList, setting = getUITextListAndImage(text, atlas)
        if #textList == 0 then
            return
        end
        local desktop = GUISystem.instance:GetRootWindow()
        scale = scale or setting.scale or 1
        local win, widthSum, maxHeight = UILib.makeTextUIGrid("showFlyWordUI", textList, setting.imageSet)
        win:SetTouchable(false)
        win:SetLevel(100)
        desktop:AddChildWindow(win)
        if setting.useAnim == "secondAnim" then
            FlyTextHelper:onShowUIFlyUpTextAnim(win, widthSum, maxHeight, scale, setting)
        else
            FlyTextHelper:onShowUIFlyTextAnim(win, widthSum, maxHeight, scale, setting)
        end
    else
        local packet = {
            pid = "onShowFlyText",
            type = FlyTextType.UI,
            atlas = atlas,
            text = text,
            scale = scale
        }
        target:sendPacket(packet)
    end
end

--重写了引擎内的该方法实现自定义动画
function FlyTextHelper:onShowEntityFlyTextAnim(fromEntity, setting, textList, scale)
    local startPos = fromEntity:getEyePos()
    local offsetX = (math.random(1, 2) == 1 and -math.random(2,5) or math.random(2,5)) / 100
    local offsetZ = (math.random(1, 2) == 1 and -math.random(2,5) or math.random(2,5)) / 100
    local offsetY = setting.offsetY or math.random(50,65) / 100
    local acceleration = setting.offsetAcceleration or 0.08
    local ticks = setting.duration or 20
    local endScale = setting.endScale or (scale / 1.5)
    local offsetScale = (scale - endScale) / ticks
    local image = WorldImageRender.Instance():addWorldImage(textList, startPos, scale, -1)
    local times = 0
    FlyTaskList[tostring(image)] = function()
        startPos = startPos + Lib.v3(offsetX, offsetY, offsetZ)
        scale = scale - offsetScale
        image.position = startPos
        image.scale = scale
        times = times + 1
        offsetY = offsetY - acceleration
        if times >= ticks then
            image.duration = 0
        end
        return times < ticks
    end
end

-- 两段上升飘字动画
function FlyTextHelper:onShowEntityFlyUpAnim(fromEntity, setting, textList, scale)
    local startPos = fromEntity:getEyePos()
    local actionStage = {
        [1] = {
            startScale = scale or 1,
            endScale = 1.5,
            duration = 2,
            offsetX = (math.random(1, 2) == 1 and -math.random(1,2) or math.random(1,2)) / 100,
            offsetZ = (math.random(1, 2) == 1 and -math.random(1,2) or math.random(1,2)) / 100,
            offsetY = 0.15,
        },
        [2] = {
            startScale = 1.5,
            endScale = 1,
            duration = 3,
            offsetX = 0,
            offsetZ = 0,
            offsetY = 0.15,
        },
        [3] = {
            startScale = 1,
            endScale = 1,
            duration = 6,
            offsetX = 0,
            offsetZ = 0,
            offsetY = 0.03,
        },
        [4] = {
            startScale = 1,
            endScale = 0,
            duration = 6,
            offsetX = 0,
            offsetZ = 0,
            offsetY = 0.03,
        }
    }

    local image = WorldImageRender.Instance():addWorldImage(textList, startPos, actionStage[1].startScale, -1)
    local times = 0
    local curState = 1
    local preTime = 0
    FlyTaskList[tostring(image)] = function()
        if not actionStage[curState] then
            image.duration = 0
            return false
        end
        times = times + 1
        local passTime = times - preTime

        startPos = startPos + Lib.v3(actionStage[curState].offsetX, actionStage[curState].offsetY, actionStage[curState].offsetZ)
        image.position = startPos

        local changeScale = passTime*(actionStage[curState].endScale - actionStage[curState].startScale)/actionStage[curState].duration
        image.scale = actionStage[curState].startScale + changeScale

        if times >= preTime + actionStage[curState].duration then
            preTime = preTime + actionStage[curState].duration
            curState = curState + 1
        end
        return true
    end
end

function FlyTextHelper:onShowEntityDynamicFlyTextAnim(fromEntity, setting, textList, scale)
    local startPos = fromEntity:getEyePos()
    local offset = setting.offset or Lib.v3(0.5, 1, 0.5)
    offset = Lib.tov3(offset) * scale
    local x = math.random(1, 2) == 1 and -offset.x or offset.x
    local endPos = startPos + Lib.v3(x, offset.y, x)
    local ticks = (setting.stableDuration or 5) + (setting.reduceDuration or 0) + (setting.enlargeDuration or 5)
    local offsetPos = (endPos - startPos) / ticks
    local image = WorldImageRender.Instance():addWorldImage(textList, startPos, scale, -1)
    local times = 0
    image.scale = 0
    FlyTaskList[tostring(image)] = function()
        startPos = startPos + offsetPos
        image.position = startPos

        if times <= (setting.enlargeDuration or 5) then
            image.scale = image.scale + (setting.enlargeSpeed or 0.5)
        elseif times > (setting.stableDuration or 5) + (setting.enlargeDuration or 5) then
            image.scale = image.scale - (setting.enlargeSpeed or 0.5)
        end

        times = times + 1
        if times >= ticks then
            image.duration = 0
        end
        return times < ticks
    end
end

---给玩家发送一个Entity头顶飘字
---@param fromEntity Entity 来源Entity
---@param atlas number|string 图集标识
---@param text string 飘字内容
---@param scale number 飘字缩放
---@param isScaleDynamic boolean 缩放是否是动态变化的
function FlyTextHelper:onShowEntityFlyText(fromEntity, atlas, text, scale, isScaleDynamic)
    if not fromEntity:isValid() then
        return
    end
    text = string.gsub(text, "%.", "d")
    if World.isClient then
        local textList, setting = getUITextListAndImage(text, atlas)
        if #textList == 0 then
            return
        end
        if setting.interval then
            local tickCount = World.CurWorld:getTickCount()
            local ticks = tickCount - (fromEntity.showFlyTextTick or 0)
            if ticks < setting.interval then
                World.LightTimer("FlyTextHelper:onShowEntityFlyText", ticks, function()
                    FlyTextHelper:onShowEntityFlyText(fromEntity, atlas, text, scale, isScaleDynamic)
                end)
                return
            end
            fromEntity.showFlyTextTick = tickCount
        end
        scale = scale or setting.scale or 1

        if isScaleDynamic then
            FlyTextHelper:onShowEntityDynamicFlyTextAnim(fromEntity, setting, textList, scale)
        elseif setting.useAnim == "secondAnim" then
            FlyTextHelper:onShowEntityFlyUpAnim(fromEntity, setting, textList, scale)
        else
            FlyTextHelper:onShowEntityFlyTextAnim(fromEntity, setting, textList, scale)
        end
    else
        local packet = {
            pid = "onShowFlyText",
            fromObjID = fromEntity.objID,
            type = FlyTextType.Entity,
            atlas = atlas,
            text = text,
            scale = scale
        }
        fromEntity:sendPacketToTracking(packet, true)
    end
end

if not World.isClient then
    return
end

----------------以下只有客户端会调用----------------

---客户端接收飘字数据包
local handles = T(Player, "PackageHandlers")
function handles:onShowFlyText(packet)
    FlyTextHelper:onReceiveFlyText(packet)
end

function FlyTextHelper:onReceiveFlyText(packet)
    if packet.type == FlyTextType.UI then
        FlyTextHelper:onShowUIFlyText(Me, packet.atlas, packet.text, packet.scale)
    elseif packet.type == FlyTextType.Entity then
        local fromEntity = World.CurWorld:getEntity(packet.fromObjID)
        if fromEntity then
            FlyTextHelper:onShowEntityFlyText(fromEntity, packet.atlas, packet.text, packet.scale)
        end
    end
end

---初始化配置里面的图集
function FlyTextHelper:init()
    local folderRoot = World.cfg.fly_textSetting and World.cfg.fly_textSetting.path or "assert"
    local settings = Lib.readGameJson(folderRoot.."/fly_text/setting.json")

    if not settings then
        Lib.logWarning("[Plugins]FlyTextHelper", Root.Instance():getGamePath() .. "assert/fly_text/setting.json is not exists.")
        return
    end
    local lfs = require("lfs")
    for _, setting in pairs(settings) do
        local atlas = setting.atlas or setting.folder
        WordSetting[atlas] = setting
        setting.words = {}
        if setting.folder then
            local path = Lib.combinePath(Root.Instance():getGamePath() .. folderRoot.."/fly_text", setting.folder) .. "/"
            local attr = lfs.attributes(path)
            if not attr or attr.mode ~= "directory" then
                goto CONTINUE
            end
            setting.folder = Lib.combinePath(  folderRoot.."/fly_text", setting.folder)
            for file in lfs.dir(path) do
                if file:find(".png") then
                    local word = file:gsub(".png", "")
                    table.insert(setting.words, word)
                    TextureAtlasRegister.instance:addMemTextureAtlas("FlyText",
                            Lib.combinePath(setting.folder, file))
                end
            end
        end
        if setting.imageSet then
            local result = Lib.readGameJson(World.cfg.fly_textSetting.path .. "/fly_text/" .. setting.imageSet .. ".json")
            if result then
                for key, _ in pairs(result.frames) do
                    table.insert(setting.words, key)
                end
            end
        end
        :: CONTINUE ::
    end
    World.LightTimer("FlyTextHelper:onTick", 1, function()
        return FlyTextHelper:onTick()
    end)
end

function FlyTextHelper:onTick()
    for key, task in pairs(FlyTaskList) do
        if not task() then
            FlyTaskList[key] = nil
        end
    end
    return true
end

FlyTextHelper:init()