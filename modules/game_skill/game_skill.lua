---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by 10184.
--- DateTime: 2020/12/25 13:27
--- 游戏技能表现插件
--- 使用该插件将插件csv目录下的“skill_moves.csv和game_skill_sound.csv”拷贝到项目的config里面即可生效
---

require "common.game_skill_define"
require "common.game_skill_event"
require "common.config.skill_moves_config"
require "common.config.game_skill_sound_config"
require "common.config.skill_config"
require "common.config.hurt_color_timeline_config"
require "common.config.skill_buff_config"

require "common.entity.game_skill_entity"

require "common.helper.game_skill_helper"
require "common.helper.skill_helper"
require "common.game_skill_overwrite_common"

if World.isClient then
    require "client.entity.entity_color_animator"
    require "client.entity.game_skill_entity"
    require "client.player.player_game_skill"
    require "client.helper.game_skill_helper"
    require "client.player.packet_game_skill"
    require "client.helper.sprint_skill_helper"
    require "client.gen_skill_file_helper"
    require "client.gm_game_skill"
    require "client.skill.sprint_skill"
    require "client.skill.fly_skill"
    require "client.skill.state_skill"
    require "client.game_skill_overwrite"
    require "client.cast_helper.game_skill_cast_helper"
else
    require "server.entity.entity_game_skill"
    require "server.player.player_game_skill"
    require "server.helper.game_skill_helper"
    require "server.skillClass.base_skill"
    require "server.skillClass.attack_skill"
    require "server.skillClass.jump_skill"
    require "server.skillClass.sprint_skill"
    require "server.helper.skill_helper"
    require "server.skill.sprint_skill"
    require "server.skill.state_skill"
    require "server.skill.fly_skill"
    require "server.game_skill_overwrite"
end

---@type GameSkillHelper
local GameSkillHelper = T(Lib, "GameSkillHelper")
---@type SkillMovesConfig
local SkillMovesConfig = T(Config, "SkillMovesConfig")
---@type GameCameraControl
local GameCameraControl = T(Lib, "GameCameraControl")
---@type SkillBuffConfig
local SkillBuffConfig = T(Config, "SkillBuffConfig")

local handlers = {}

function handlers.tryEntityFreeSkill(entity, skillId, ...)
    GameSkillHelper:onEntityFreeSkill(entity, skillId, ...)
end

function handlers.setDefaultUpperAction(entity, action)
    GameSkillHelper:setDefaultUpperAction(entity, action)
end

Lib.subscribeEvent(Event.EventCastSkill,function (skillId,entity,packet)
    local cfg=SkillMovesConfig:getNewSkillConfig(skillId)
    if cfg and cfg.shakeCamera and entity and entity:isValid() then
        local shake=false
        if entity.objID == Me.objID then
            shake=true
        else
            shake=cfg.shakeCamera.broadcastRange>0 and Lib.getPosDistanceSqr(Me:getPosition(),entity:getPosition())<=
                    cfg.shakeCamera.broadcastRange*cfg.shakeCamera.broadcastRange
        end
        --print("=========== receive Event.EventCastSkill",skillId,shake,Lib.getPosDistance(Me:getPosition(),entity:getPosition()))
        if shake then
            GameCameraControl:tryShakeCamera(cfg.shakeCamera)
        end
    end

    if entity.objID == Me.objID and cfg and cfg.attackerVariableTime and cfg.attackerVariableTime>0 and entity and entity:isValid() then
        entity:clientVibratorOnTime(cfg.attackerVariableTime)
    end

    if packet and packet.autoCast then
        if cfg.castSound then
            --- @type SoundManager
            local SoundManager = T(Lib, "SoundManager")
            SoundManager:playSound(cfg.castSound,entity)
        end
    end
    entity:setPlayerActionInf(nil)
end)

local function getMissileCenterOffsetY(collideInf)
    local offsetY=0
    if collideInf then
        if collideInf.type=="Box" then
            offsetY=collideInf.extent.y/2
        elseif collideInf.type=="Cylinder" then
            offsetY=collideInf.height/2
        elseif collideInf.type=="Sphere" then
            offsetY=collideInf.radius
        end
    end
    --print("----------------------------getMissileCenterOffsetY,type, offsetY ",collideInf.type,offsetY)
    return offsetY
end

local function dragEntity(context)
    local moveTime = context.missile:cfg().dragTarget.dragTargetTime
    local toPos
    if context.missile:cfg().dragTarget.dragTargetType==Define.dragTargetType.ToAttacker then
        toPos=context.obj2:getPosition()
    else
        toPos=context.missile:getPosition()
        if context.missile:cfg().dragTarget.dragToMissileCenter then
            toPos.y=toPos.y+getMissileCenterOffsetY(context.missile:cfg().collider)
        end
    end

    local dir=   Lib.tov3(context.obj1:getPosition())-toPos
    dir:normalize()
    toPos.x=toPos.x+dir.x*1
    toPos.z=toPos.z+dir.z*1
    --print(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> hit drag target:",toPos, moveTime,context.obj1.isPlayer)
    if context.obj1.isPlayer then
        context.obj1:setForceMoveToAll(toPos, moveTime)
        if context.obj1.gravityDragTimer then
            context.obj1.gravityDragTimer()
        end
        context.obj1:setDragState(1)
        context.obj1.gravityDragTimer=World.Timer(moveTime,function()
            --print(">>>>>>>>>>>>>>>>>>context.obj1")
            if context.obj1:isValid() then
                context.obj1:setDragState(0)
            end
        end)
    else
        context.obj1:setForceMove(toPos, moveTime)
    end
    context.obj1:syncForceMove()
end

function handlers.ENTITY_HITTED(context)
    --print("+++++++++++++++++++++++++++ handlers.ENTITY_HITTED",context.obj1.objID,context.obj2.objID,context.obj2.isPlayer)
    if not context.obj1 or not context.obj1:isValid() then
        return
    end
    if not context.obj1:isInCanAttackState(context.obj2) then
        return
    end

    if context.missile:cfg().hitBuff  then
        local buffList=Lib.splitString(context.missile:cfg().hitBuff,"#",true)
        for _, buffId in pairs(buffList) do
            local buff=SkillBuffConfig:getCfgByBuffId(buffId)
            if buff then
                --print("+++++++++++++++++++++ handlers.ENTITY_HITTED,add buff",buff.buffName, buff.duration)
                context.obj1:addBuff(buff.buffName, buff.duration, context.obj2)
            end
        end
    end

    if not context.obj2 or not context.obj2:isValid() then
        return
    end
    if context.missile:cfg().dragTarget then
        dragEntity(context)
    end
end

function handlers.SKILL_CAST(context)
    local skillSetting = Skill.Cfg(context.fullName)
    local owner=context.obj1
    --print("---------------->>handlers.SKILL_CAST",skillSetting.skillId,skillSetting.type,owner:isMonster())
    if not owner or not owner:isValid() or not owner:isMonster() or not skillSetting or skillSetting.type~="Missile" then
        return
    end

    local cfg=SkillMovesConfig:getNewSkillConfig(skillSetting.skillId)
    if cfg then
        if cfg.move then
            if cfg.move.delay > 0 then
                if owner.delayActionMoveTimer then
                    owner.delayActionMoveTimer()
                end
                owner.delayActionMoveTimer=World.Timer(cfg.move.delay*20,function ()
                    if not owner:isInImmobilityState() then
                        owner:enterStateType(Define.RoleStatus.SKILL_MOVE_STATE,skillSetting.skillId,false)
                    end
                end)
            else
                owner:enterStateType(Define.RoleStatus.SKILL_MOVE_STATE,skillSetting.skillId,false)
            end
        end
    end
end


return function(name, ...)
    if type(handlers[name]) ~= "function" then
        return
    end
    handlers[name](...)
end