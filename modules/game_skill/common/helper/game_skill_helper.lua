---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by 10184.
--- DateTime: 2020/12/25 15:20
---
local SkillHitType = {
    CircleRange = 1, ---圆形
    RayRange = 2, ---射线
    SectorRange = 3, ---扇形
}

---@class GameSkillHelper
local GameSkillHelper = T(Lib, "GameSkillHelper")
---@type SkillMovesConfig
local SkillMovesConfig = T(Config, "SkillMovesConfig")
---@type SkillConfig
local SkillConfig = T(Config, "SkillConfig")
---@type SkillBuffConfig
local SkillBuffConfig = T(Config, "SkillBuffConfig")
---@type AbilitySystem
local AbilitySystem = T(Lib, "AbilitySystem")
---@type GrowthSystem
local GrowthSystem = T(Lib, "GrowthSystem")

---范围球形检测
---@param target Entity
local function checkCircleRange(target, _, hitPos, range)
    local boundingBox = target:getBoundingBox()
    local box = boundingBox[3] - boundingBox[2]
    local centerPos = boundingBox[2] + box / 2
    return (hitPos - centerPos):len() <= box:len() / 2 + range
end

---范围射线检测
---@param target Entity
local function checkRayRange(target, startPos, hitPos, range)
    local pos = target:getPosition()
    local per
    if startPos.x ~= hitPos.x then
        per = (pos.x - startPos.x) / (hitPos.x - startPos.x)
    elseif startPos.y ~= hitPos.y then
        per = (pos.y - startPos.y) / (hitPos.y - startPos.y)
    elseif startPos.z ~= hitPos.z then
        per = (pos.z - startPos.z) / (hitPos.z - startPos.z)
    end
    if per and math.abs(per) < 1 then
        local newPos = startPos + (hitPos - startPos) * per
        if checkCircleRange(target, startPos, newPos, range) then
            return true
        end
    end
    if checkCircleRange(target, startPos, startPos, range) then
        return true
    end
    if checkCircleRange(target, startPos, hitPos, range) then
        return true
    end
    return false
end

---扇形范围检测
---@param target Entity
local function checkSectorRange(target, _, hitPos, range, yaw, angle)
    local pos = target:getPosition()
    local x = math.abs(hitPos.x - pos.x)
    local y = math.abs(hitPos.z - pos.z)
    local distance = math.sqrt(x * x + y * y)
    if distance < 1 then
        return true
    end
    if distance > range then
        return false
    end
    yaw = yaw % 360
    local targetDir = (math.atan(pos.x - hitPos.x, pos.z - hitPos.z) / math.pi * -180) % 360
    local angle1 = targetDir - angle / 2
    local angle2 = targetDir + angle / 2
    if angle1 <= yaw and angle2 >= yaw then
        return true
    end
    return false
end

local function checkAllEntity(_, _)
    return true
end

local function checkSelf(freeEntity, target)
    return freeEntity == target
end

local function checkOtherEntity(freeEntity, target)
    return freeEntity ~= target
end

local function checkOtherPlayer(freeEntity, target)
    return freeEntity ~= target and target.isPlayer
end

local function checkOtherEntityExceptPlayer(freeEntity, target)
    return freeEntity ~= target and not target.isPlayer
end

local SkillTargetFunc = {
    ["0"] = checkAllEntity,
    ["1"] = checkSelf,
    ["2"] = checkOtherEntity,
    ["3"] = checkOtherPlayer,
    ["4"] = checkOtherEntityExceptPlayer,
}

-- 可攻击的目标
function GameSkillHelper:getCanHitTargets(freeEntity, skill, entities)
    local targets = {}
    --local checkFunc = SkillTargetFunc[tostring(skill.hitTarget)] or checkAllEntity
    --for _, target in pairs(entities) do
    --    if not target:isInCanAttackState(freeEntity)then
    --        goto CONTINUE
    --    end
    --    if checkFunc(freeEntity, target) then
    --        table.insert(targets, target)
    --    end
    --    ::CONTINUE::
    --end
    return targets
end

---重新计算起点坐标，去掉背后的半圆
local function recalculateStartPos(skill, startPos, hitPos)
    if skill.hitRange <= 0 then
        return startPos
    end
    if startPos == hitPos then
        return startPos
    end
    local offset = hitPos - startPos
    return startPos + (skill.hitRange / offset:len()) * offset
end

function GameSkillHelper:GetNearestTarget(skill,entity,distanceLimit)
    if not skill or skill.hitTarget==1 or not entity then
        return nil
    end
    local dis=distanceLimit
    if not dis or dis<=0 then
        dis=5
    end
    local entityList = entity:getNearbyEntities(dis, function(obj)
        return entity ~= obj and obj.curHp > 0 and obj:isValid()
    end)
    entityList = GameSkillHelper:getCanHitTargets(entity, skill, entityList)
    if #entityList == 0 then
        return nil
    end

    local minDistance
    local target
    for _, obj in pairs(entityList or {}) do
        local distance = entity:distance(obj)
        if not minDistance or  distance < minDistance then
            minDistance = distance
            target = obj
        end
    end
    return target
end

---@param freeEntity
---@param skill GameSkill 技能配置
function GameSkillHelper:doGameSkillResult(freeEntity, skill, startPos, hitPos)
    local entities = World.CurWorld:getAllEntity()
    local entityList = {}
    for _, entity in pairs(entities) do
        if skill.hitSameTargetTimes <= 0 or (skill.hitTargetTimes[entity.objID] or 0) < skill.hitSameTargetTimes then
            ---没有超过命中次数限制，添加到检测队列中
            table.insert(entityList, entity)
        end
    end
    local checkRangeFunc
    if skill.hitType == SkillHitType.CircleRange then
        checkRangeFunc = checkCircleRange
    elseif skill.hitType == SkillHitType.RayRange then
        startPos = recalculateStartPos(skill, startPos, hitPos)
        checkRangeFunc = checkRayRange
    elseif skill.hitType == SkillHitType.SectorRange then
        checkRangeFunc = checkSectorRange
    else
        checkRangeFunc = checkCircleRange
    end
    entityList = GameSkillHelper:getCanHitTargets(freeEntity, skill, entityList)
    if #entityList == 0 then
        return
    end
    local targets = {}
    for _, target in pairs(entityList) do
        if checkRangeFunc(target, startPos, hitPos, skill.hitRange, freeEntity:getRotationYaw(), skill.hitAngle or 30) then
            skill.hitTargetTimes[target.objID] = (skill.hitTargetTimes[target.objID] or 0) + 1
            table.insert(targets, target.objID)
        end
    end
    if #targets == 0 then
        return
    end
    if World.isClient then
        Me:sendPacket({ pid = "doGameSkillResult", skillId = skill.skillId, freeObjID = freeEntity.objID, targets = targets })
    else
        Lib.emitEvent(Event.EventGameSkillResult, freeEntity, skill.skillId, targets)
    end
end

--- 毫秒,获奖技能花费时长
function GameSkillHelper:getSkillTotalTime(skillId, freeEntity)
    local skillCfg=SkillConfig:getSkillConfig(skillId)
    if not skillCfg or skillCfg.isEngineSkill then
        return self:getEngineSkillTotalTime(skillId, freeEntity)
    end

    local realSkill = SkillMovesConfig:getSkillConfig(skillId)
    local totalTime = 0
    if realSkill then
        if realSkill.preAction then
            if World.isClient and freeEntity then
                ---获取动作时间长度(单位：帧)
                local time = freeEntity:getUpperActionTicks(realSkill.preAction) or 0
                totalTime = totalTime + math.ceil(time/20*1000)
            else
                totalTime = totalTime + 200
            end
        end

        totalTime = totalTime + realSkill.actionDelayTime

        local castTime = 0
        if realSkill.castAction then
            if World.isClient and freeEntity then
                local time = freeEntity:getUpperActionTicks(realSkill.castAction) or 0
                castTime = math.ceil(time/20*1000)
            else
                totalTime = totalTime + 200
            end
        end
        if realSkill.bulletDelayTime < 0 then
            totalTime = totalTime + castTime + realSkill.duration
        else
            local bulletTime = math.max(castTime, realSkill.bulletDelayTime + realSkill.duration)
            totalTime = totalTime + bulletTime
        end

        if realSkill.endAction then
            if World.isClient and freeEntity then
                local time = freeEntity:getUpperActionTicks(realSkill.endAction) or 0
                totalTime = totalTime + math.ceil(time/20*1000)
            else
                totalTime = totalTime + 200
            end
        end
    end
    return totalTime
end

function GameSkillHelper:getEngineSkillTotalTime(skillMoveId, freeEntity)
    local realSkill = SkillMovesConfig:getNewSkillConfig(skillMoveId)
    local totalTime = 0
    if realSkill then
        if realSkill.duration then
            totalTime=realSkill.duration
        else
            local castAction=realSkill.skillInf.castAction
            local castTime = 0
            if castAction then
                if World.isClient and freeEntity then
                    local time = freeEntity:getUpperActionTicks(castAction) or 0
                    castTime = math.ceil(time/20*1000)
                else
                    castTime =  500
                end
            end
            totalTime=totalTime+castTime
        end
    end
    return totalTime
end

function GameSkillHelper:setEntityBlowAway(entity,attacker,param)
    if not entity or not entity:isValid() or entity:isInStateType(Define.RoleStatus.DEAD) or not param then
        return
    end
    --print(">>>>>>>>>>>>>>>>>>>>> :setEntityBlowAway ",entity.objID)
    local moveCfg=SkillMovesConfig:getNewSkillConfig(param.skillId)
    if not moveCfg or not moveCfg.hitBack then
        return
    end
    entity:enterStateType(Define.RoleStatus.BLOW_AWAY,attacker,param)
end

function GameSkillHelper:shootDownFlyPlayer(entity,attacker,param)
    if not entity or not entity:isValid() or entity:getFlyMode() == 0 or entity:isInStateType(Define.RoleStatus.DEAD)
        or not attacker or not attacker:isValid() or not param then
            return
    end
    local buff=SkillBuffConfig:getCfgByBuffId(World.cfg.game_skillSetting.shootDownBuffId)
    if buff then
        entity:addBuff(buff.buffName, buff.duration, attacker)
        entity.beShootDown=true
    end
    local flyBuffs=SkillBuffConfig:getAllFlyBuffCfgs()
    for _, cfg in pairs(flyBuffs) do
        entity:removeTypeBuff("fullName", cfg.buffName)
    end
    entity:sendPacket({pid="S2CCleanFlySkillState"})
    if attacker.isPlayer then
        attacker:sendPacket({pid="S2CShowShootDownEffect"})
    end
    
    local alias=""
    local ability=AbilitySystem:getAbility(entity)
    if ability then
        alias=ability:getItemAlias()
    end
    local defaultData = {
        ability_id = alias,
        player_level = GrowthSystem:getLevel(entity),
        hit_skill_id = param.skillId
    }
    Plugins.CallTargetPluginFunc("report", "report", "fly_hit_down", defaultData, entity)
end