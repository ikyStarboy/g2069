---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by 10184.
--- DateTime: 2020/12/25 15:20
---
---@class SkillMovesConfig
local SkillMovesConfig = T(Config, "SkillMovesConfig")
---@type SoundConfig
local SoundConfig = T(Config, "SoundConfig")

local GameSkillMap = {}
local NewGameSkillMap = {}

local function nullStringToNil(str)
    if str == "" then
        return nil
    end
    return str
end

function SkillMovesConfig:initSkillByConfig(config)
    ---@class GameSkill
    local data = {}
    data.id = tonumber(config.id) or 0
    data.skillId = tonumber(config.skillId) or 0
    data.isNormalAttack = tonumber(config.isNormalAttack) == 1
    data.isBeMissAttack = tonumber(config.isBeMissAttack) == 1
    data.skillClass = config.skillClass or "BaseSkill"
    data.isClientGoAhead = config.isClientGoAhead == "1"       ---是否客户端先行
    data.storageAction = config.storageAction or nil                            ---蓄力动作
    data.storageTime = config.storageTime or nil                                ---蓄力时长区间s#s
    if data.storageTime then
        data.storageTimeMin,data.storageTimeMax=self:_splitData(data.storageTime,true)
    end
    data.storageLimit = config.storageLimit or nil                              ---蓄力限制:可以移动#可转向
    if data.storageLimit then
        data.storageLimitMove,data.storageLimitRotate=self:_splitData(data.storageLimit,true)
    end
    data.storageEffect = config.storageEffect or nil                            ---蓄力特效
    data.storageSound = config.storageSound or nil                              ---蓄力音效
    data.isStopMove = config.isStopMove == "1"       ---是否停止移动
    data.isFollowBullet = config.isFollowBullet == "1" ---是否跟随弹道移动
    data.preAction = nullStringToNil(config.preAction) ---技能释放动作
    data.castSound = nullStringToNil(config.castSound)  ---技能释放音效
    data.castAction = nullStringToNil(config.castAction) ---技能释放动作
    data.actionDelayTime = tonumber(config.actionDelayTime) or 0 ---动作播放延长时间
    data.childActorName =  nullStringToNil(config.childActorName) ---子模型名称
    data.childCastAction = nullStringToNil(config.childCastAction) ---子模型释放动作
    data.bulletDelayTime = tonumber(config.bulletDelayTime) or 0 ---释放弹道延迟时间
    data.bulletOffset = Lib.strToV3(config.bulletOffset or "0,0,0") ---弹道起始偏移
    data.bulletPitch = tonumber(config.bulletPitch) or 0 ---弹道仰角，可以修改弹道移动方向
    data.bulletSound = nullStringToNil(config.bulletSound) ---弹道音效
    data.bulletEffect = nullStringToNil(config.bulletEffect or nil) ---弹道特效
    data.bulletEffectMove = config.bulletEffectMove == "1" ---弹道特效是否移动
    data.bulletEffectScale = tonumber(config.bulletEffectScale) or 1 ---弹道特效缩放
    data.duration = tonumber(config.duration) or 0 ---技能时长，没有特效或特效时长无限大的时候生效
    data.distance = tonumber(config.distance) or 0 ---技能距离
    data.hitTimes = math.max(tonumber(config.hitTimes) or 1, 1) ---技能命中次数
    data.hitRange = tonumber(config.hitRange) or 0 ---技能命中范围
    data.hitTarget = tonumber(config.hitTarget) or 0 ---技能命中目标
    data.hitType = tonumber(config.hitType) or 1 ---技能命中类型
    data.hitSound = nullStringToNil(config.hitSound or nil) ---技能命中音效
    data.hitEffect = nullStringToNil(config.hitEffect or nil) ---技能命中特效
    data.hitEffectScale = tonumber(config.hitEffectScale) or 1 ---命中特效缩放
    data.hitAngle = tonumber(config.hitAngle) or 0 ---技能命中扇形角度
    data.hitSameTargetTimes = tonumber(config.hitSameTargetTimes) or 0 ---命中同一目标次数
    data.endAction = nullStringToNil(config.endAction or nil) ---技能结束动作
    data.childEndAction = config.childEndAction or nil ---子模型结束动作
    data.comboTime = tonumber(config.comboTime) or 0 ---触发连招时间
    data.comboSkillId = tonumber(config.comboSkillId) or 0 ---触发连招技能ID
    data.autoComboSkillId =  tonumber(config.autoComboSkillId) or 0 ---自动释放连招
    data.forbidInterruptAction = config.forbidInterruptAction == "1" ---是否禁止打断动作
    data.ignoreInterruptAction = config.ignoreInterruptAction == "1" ---是否直接释放，无视技能队列
    data.hitMoveHDis =  tonumber(config.hitMoveHDis) or 0                       ---击退位移
    data.hitMoveVDis = tonumber(config.hitMoveVDis) or 0                        ---击飞高度
    data.hitMoveDuration = tonumber(config.hitMoveDuration) or 0                ---击飞击退位移时间
    data.hurtAction = nullStringToNil(config.hurtAction or nil)     ---目标受伤动作
    data.hitBuff = nullStringToNil(config.hitBuff or nil)              ---命中buff
    data.buffTarget = tonumber(config.buffTarget) or 0                          ---Buff目标 1自身2对方
    data.buffTime = tonumber(config.buffTime) or 0                              ---buff时间
    data.attackerVariableTime = tonumber(config.attackerVariableTime) or 0                              ---攻击者手机震动时间
    data.defenderVariableTime = tonumber(config.defenderVariableTime) or 0                              ---受击者手机震动时间

    return data
end

function SkillMovesConfig:_splitData(str,toNumber)
    local result=Lib.splitString(str or "", "#",toNumber)
    return table.unpack(result)
end

function SkillMovesConfig:init()
    local config = Lib.read_csv_file(Root.Instance():getGamePath() .. "config/skill_moves.csv", 2)
    for _, vConfig in pairs(config or {}) do
        if vConfig.skillId ~= "" then
            GameSkillMap[vConfig.skillId] = SkillMovesConfig:initSkillByConfig(vConfig)
        end
    end
end

---@param skillId number 技能Id
---@return GameSkill
function SkillMovesConfig:getSkillConfig(skillId)
    return GameSkillMap[tostring(skillId)]
end

---@return GameSkill[]
function SkillMovesConfig:getAllSkillConfig()
    return GameSkillMap
end

function SkillMovesConfig:initNewSkillByConfig(config)
    ---@class NewGameSkill
    local data = {}
    data.id = tonumber(config.id) or 0
    data.skillId = tonumber(config.skillId) or 0
    data.isNormalAttack = tonumber(config.isNormalAttack) == 1
    data.isBeMissAttack = tonumber(config.isBeMissAttack) == 1
    data.mark=config.mark
    data.movesDmg = tonumber(config.movesDmg) or 1
    data.skillName=self:_getSkillName(data.skillId)
    data.shakeCamera=self:_splitShakeCamera(config.shakeCamera)
    data.hitShakeCamera=self:_splitShakeCamera(config.hitShakeCamera)
    data.move=self:_splitMove(config.move)
    data.storageMove=self:_splitMove(config.storageMove)
    data.duration=tonumber(config.duration)
    data.hitTimeline = config.s_hit_timeline or ""
    data.hitBack=self:_splitHitBack(config.hitBack)
    data.storageAction =  nullStringToNil(config.storageAction)                           ---蓄力动作
    data.storageTime = nullStringToNil(config.storageTime)                                ---蓄力时长区间s#s
    if data.storageTime then
        data.storageTimeMin,data.storageTimeMax,data.storageTimePowerUp=self:_splitData(data.storageTime,true)
        if not data.storageTimePowerUp then
            data.storageTimePowerUp=data.storageTimeMax
        end
    end

    local storageEffect = nullStringToNil(config.storageEffect)                            ---蓄力特效
    if storageEffect then
        data.storageEffect={}
        data.storageEffect.effect=storageEffect
        data.storageEffect.pos,data.storageEffect.scale=self:_splitEffectParam(config.storageEffectParam)
    end
    data.storageSound=nullStringToNil(config.storageSound)                                 ---蓄力音效
    local storageLimit = nullStringToNil(config.storageLimit)                              ---蓄力限制:可以移动#可转向
    if storageLimit then
        data.storageLimitMove,data.storageLimitRotate,data.storageLimitGravity=self:_splitData(storageLimit,true)
    end
    local castLimit = nullStringToNil(config.castLimit)                                    ---蓄力限制:可以移动#可转向
    if castLimit then
        data.castLimitMove,data.castLimitRotate,data.castLimitGravity=self:_splitData(castLimit,true)
    end
    data.isStopMove=data.castLimitMove==0
    data.buffList = Lib.splitString(config.buffList or "", "#", true)
    data.flySpeedRate=config.flySpeedRate or 1
    local childActorInf=Lib.splitString(config.childActorAction or "", "#", true)
    data.childActorAction=childActorInf[1]~=nil and childActorInf[1]==1
    data.childActorActionDur=childActorInf[2] or 1
    data.castSound=nullStringToNil(config.castSound)
    data.storageParam=self:_splitStorageParam(config.storageParam)
    data.attackerVariableTime = tonumber(config.attackerVariableTime) or 0                              ---攻击者手机震动时间
    data.defenderVariableTime = tonumber(config.defenderVariableTime) or 0                              ---受击者手机震动时间

    ---@class GenSkillInf
    local skillInf={}
    skillInf.type=config.type or "Missile"
    skillInf.castAction = nullStringToNil(config.castAction)
    local castEffect=nullStringToNil(config.castEffect)
    if castEffect then
        skillInf.castEffect ={}
        skillInf.castEffect.effect=castEffect
        skillInf.castEffect.pos,skillInf.castEffect.scale=self:_splitEffectParam(config.castEffectParam)
    end
    self:_splitSkillSound(config.castSound,"castSound",skillInf)
    skillInf.missileCount = tonumber(config.missileCount) or 0
    skillInf.startWait=self:_splitNumberArray(config.startWait)
    skillInf.startPos=self:_splitVectorArray(config.startPos)
    skillInf.startYaw=self:_splitNumberArray(config.startYaw)
    skillInf.startPitch=self:_splitNumberArray(config.startPitch)
    if skillInf.missileCount >= 1 then
        skillInf.missileCfg=self:_getMissileName(data.skillId)
    end
    skillInf.skillId=data.skillId
    skillInf.startFrom="foot"
    skillInf.targetType=nullStringToNil(config.targetType)
    if skillInf.targetType == "Self" then
        skillInf.target="self"
    end
    local castSceneEffect=nullStringToNil(config.castSceneEffect)
    if castSceneEffect then
        skillInf.castSceneEffect ={}
        skillInf.castSceneEffect.effect=castSceneEffect
        self:_splitSceneEffectParam(config.castSceneEffectParam,skillInf.castSceneEffect)
    end
    data.skillInf=skillInf

    ---@class GenMissileInf
    local missileInf={}
    --missileInf.boundingVolume ={}
    --missileInf.boundingVolume.type,missileInf.boundingVolume.params=self:_splitBoundingVolume(config.boundingVolume)
    missileInf.collider={}
    self:_splitCollide(config.boundingVolume,missileInf.collider)
    missileInf.moveSpeed = tonumber(config.moveSpeed)
    missileInf.moveAcc = tonumber(config.moveAcc)
    missileInf.gravity = tonumber(config.gravity)
    missileInf.rotateSpeed = tonumber(config.rotateSpeed)
    --missileInf.isPitch = tonumber(config.isPitch)~=nil and tonumber(config.isPitch)==1
    missileInf.lifeTime = tonumber(config.lifeTime)
    missileInf.vanishTime = tonumber(config.vanishTime)
    missileInf.collideEntity = tonumber(config.collideEntity)
    missileInf.hitInterval = tonumber(config.hitInterval)
    missileInf.hitEntityCount = tonumber(config.hitEntityCount)
    if tonumber(config.startSkill) then
        missileInf.startSkill=self:_getSkillName(config.startSkill)
    end
    if tonumber(config.hitEntitySkill) then
        missileInf.hitEntitySkill=self:_getSkillName(config.hitEntitySkill)
    elseif data.movesDmg then
        data.genDefaultDamageSkill=true
        missileInf.hitEntitySkill=self:_getDefaultDamageSkillName(data.skillId)
    end
    if tonumber(config.vanishSkill) then
        missileInf.vanishSkill=self:_getSkillName(config.vanishSkill)
    end
    local startEffect=nullStringToNil(config.startEffect)
    if startEffect then
        missileInf.startEffect ={}
        missileInf.startEffect.effect=startEffect
        missileInf.startEffect.pos,missileInf.startEffect.scale=self:_splitEffectParam(config.startEffectParam)
    end
    local hitEntityEffectCustom=nullStringToNil(config.hitEntityEffectCustom)
    if hitEntityEffectCustom then
        missileInf.hitEntityEffectCustomName=Define.GenHitEffectBuffPrefix..tostring(data.skillId)
        local effectInf={}
        effectInf.effect=hitEntityEffectCustom
        effectInf.pos,effectInf.scale=self:_splitEffectParam(config.hitEntityEffectParam)
        effectInf.once=true
        data.hitEntityEffectCustom={}
        data.hitEntityEffectCustom.effect=effectInf
        data.hitEntityEffectCustom.deadRemove=true
        data.hitEntityEffectCustomName=missileInf.hitEntityEffectCustomName
    end
    local vanishEffect=nullStringToNil(config.vanishEffect)
    if vanishEffect then
        missileInf.vanishEffect ={}
        missileInf.vanishEffect.effect=vanishEffect
        missileInf.vanishEffect.pos,missileInf.vanishEffect.scale=self:_splitEffectParam(config.vanishEffectParam)
    end
    self:_splitSkillSound(config.startSound,"startSound",missileInf)
    self:_splitSkillSound(config.hitEntitySound,"hitEntitySound",missileInf)
    self:_splitSkillSound(config.vanishSound,"vanishSound",missileInf)
    missileInf.vanishOnHitPart=true
    missileInf.collisionGroup=tonumber(config.collideGroup) or Define.CollisionGroup.Missile2
    missileInf.followTarget=tonumber(config.followTarget)~=nil and tonumber(config.followTarget)==1
    if config.followTargetPositionOffset   then
        missileInf.followTargetPositionOffset=self:_splitVector(config.followTargetPositionOffset , ",",0)
    end
    if config.followTargetRotationOffset   then
        missileInf.followTargetRotationOffset=self:_splitVector(config.followTargetRotationOffset , ",",0)
    end
    if missileInf.followTarget then
        if missileInf.followTargetPositionOffset then
            missileInf.followTargetPosition=true
        end
        if missileInf.followTargetRotationOffset then
            missileInf.followTargetRotation=true
        end
    end
    missileInf.hitBuff=nullStringToNil(config.hitBuff)
    missileInf.autoRotateColliderBox=true
    self:_splitDragTarget(config.dragTarget,missileInf)
    missileInf.skillId=data.skillId
    data.missileInf=missileInf
    return data
end

function SkillMovesConfig:checkStopMoveOnCast(skillMoveId)
    local cfg=self:getNewSkillConfig(skillMoveId)
    return cfg and cfg.castLimitMove==0
end

function SkillMovesConfig:checkStopMoveOnCharge(skillMoveId)
    local cfg=self:getNewSkillConfig(skillMoveId)
    return cfg and cfg.storageLimitMove==0
end

function SkillMovesConfig:checkGravityLimitOnCast(skillMoveId)
    local cfg=self:getNewSkillConfig(skillMoveId)
    return cfg and cfg.castLimitGravity==0
end

function SkillMovesConfig:checkGravityLimitOnCharge(skillMoveId)
    local cfg=self:getNewSkillConfig(skillMoveId)
    return cfg and cfg.storageLimitGravity==0
end

function SkillMovesConfig:checkRotateLimitOnCast(skillMoveId)
    local cfg=self:getNewSkillConfig(skillMoveId)
    return cfg and cfg.castLimitRotate==0
end

function SkillMovesConfig:checkRotateLimitOnCharge(skillMoveId)
    local cfg=self:getNewSkillConfig(skillMoveId)
    return cfg and cfg.storageLimitRotate==0
end

function SkillMovesConfig:_splitSkillData(str,toNumber)
    local result=Lib.splitString(str or "", "#",toNumber)
    return table.unpack(result)
end

function SkillMovesConfig:_splitEffectParam(str)
    local result=Lib.splitString(str or "", "#")
    local posData=Lib.splitString(result[1] or "", ",",true)
    local scale=tonumber(result[2]) or 1
    local pos={}
    pos.x=posData[1] or 1
    pos.y=posData[2] or 1
    pos.z=posData[3] or 1
    return pos,{x=scale,y=scale,z=scale}
end

function SkillMovesConfig:_splitSceneEffectParam(str,infTable)
    local result=Lib.splitString(str or "", "#")
    local posData=Lib.splitString(result[1] or "", ",",true)
    local scale=tonumber(result[2]) or 1
    local delay=tonumber(result[3]) or 0
    local follow=tonumber(result[4]) or 0
    local pos={}
    pos.x=posData[1] or 0
    pos.y=posData[2] or 0
    pos.z=posData[3] or 0
    infTable.pos=pos
    infTable.scale={x=scale,y=scale,z=scale}
    infTable.delay=delay
    infTable.isFixedPosition=follow~=1
    infTable.time=World.cfg.game_skillSetting.castSceneEffectDuration or 4000
    infTable.yaw=0
end

function SkillMovesConfig:_splitBoundingVolume(str)
    local result=Lib.splitString(str or "", "#")
    local type=result[1] or "Box"
    local paramsData=Lib.splitString(result[2] or "", ",",true)
    local params={}
    params[1]=paramsData[1] or 1
    params[2]=paramsData[2] or 1
    params[3]=paramsData[3] or 1
    return type,params
end

function SkillMovesConfig:_splitCollide(str,collider)
    local result=Lib.splitString(str or "", "#")
    local type=result[1] or "Box"
    local extentData=Lib.splitString(result[4] or "", ",",true)
    --local offsetData=Lib.splitString(result[3] or "", ",",true)
    local rotationData=Lib.splitString(result[5] or "", ",",true)

    local function stuff(data)
        local t={}
        t.x=data[1] or 0
        t.y=data[2] or 0
        t.z=data[3] or 0
        return t
    end
    collider.type=type
    collider.radius=tonumber(result[2]) or 1
    collider.height=tonumber(result[3]) or 1
    collider.extent=stuff(extentData)
    --collider.offset=stuff(offsetData)
    collider.rotation=stuff(rotationData)

end

function SkillMovesConfig:_splitVectorArray(str)
    local result=Lib.splitString(str or "", "#")
    local list={}
    for i = 1, #result do
        local vectorData=Lib.splitString(result[i], ",",true)
        local v={}
        v.x=vectorData[1] or 1
        v.y=vectorData[2] or 1
        v.z=vectorData[3] or 1
        table.insert(list,v)
    end
    if #list<=1 then
        return list[1] or {x=1,y=1,z=1}
    else
        return list
    end
end

function SkillMovesConfig:_splitVector(str,sep,default)
    local defaultValue=default or 0
    local result=Lib.splitString(str or "", sep or "#")
    if #result~=3 then
        return nil
    end
    local v={}
    v.x=result[1] or defaultValue
    v.y=result[2] or defaultValue
    v.z=result[3] or defaultValue
    return v
end

function SkillMovesConfig:_splitNumberArray(str)
    local result=Lib.splitString(str or "", "#",true)
    if #result<=1 then
        return result[1] or 0
    else
        return result
    end
end

function SkillMovesConfig:_splitSkillSound(str,strKey,tableInf)
    if not strKey or not tableInf then
        return
    end
    local soundCfg = SoundConfig:getSound(str)
    if soundCfg then
        tableInf[strKey]={}
        tableInf[strKey].sound=soundCfg.sound
        tableInf[strKey].loop=soundCfg.loop
        tableInf[strKey].volume=soundCfg.volume
        tableInf[strKey].losslessDistance=soundCfg.losslessDistance
        tableInf[strKey].maxDistance=soundCfg.maxDistance
        tableInf[strKey].is3dSound=soundCfg.is3dSound
        tableInf[strKey].attenuationType="0"
        --print("---------------------------->>>>>_splitSkillSound",Lib.v2s(tableInf[strKey]))
    end
end

function SkillMovesConfig:_splitShakeCamera(str)
    if not str then
        return
    end
    local result=Lib.splitString(str or "", "#",true)
    if #result>=5 then
        local data={}
        data.duration=result[1]
        data.onceDuration=result[2]
        data.amplitude=result[3]
        data.reduce=result[4]
        data.delay=result[5] or 0
        data.broadcastRange=result[6] or 0
        return data
    end
end

function SkillMovesConfig:_splitMove(str)
    if not str then
        return
    end
    local result=Lib.splitString(str or "", "#",true)
    if #result>=4 then
        local data={}
        data.pitch=result[1]
        data.speed=result[2]
        data.acc=result[3]
        data.duration=result[4]
        data.delay=result[5] or 0
        data.changeDir=false
        return data
    end
end

function SkillMovesConfig:_splitHitBack(str)
    if not str then
        return
    end
    local result=Lib.splitString(str or "", "#",true)
    if #result==4 then
        local data={}
        data.Vx=result[2]
        data.Vy=result[1]
        data.Ax=result[3]
        data.dir=result[4]
        return data
    end
end

function SkillMovesConfig:_splitDragTarget(str,infTable)
    if not str then
        return
    end
    local result=Lib.splitString(str or "", "#",true)
    if #result>=2 then
        infTable.dragTarget={}
        infTable.dragTarget.dragTargetTime=(result[1] or 1)*20
        infTable.dragTarget.dragTargetType=result[2] or 0
        infTable.dragTarget.dragToMissileCenter=result[3] and result[3]==1
    end
end

function SkillMovesConfig:_splitStorageParam(str)
    if not str then
        return
    end
    local result=Lib.splitString(str or "", "#",true)
    if #result>=4 then
        local data={}
        data.dmg=result[1]
        data.missileSpeed=result[2]
        data.hitBack=result[3]
        data.move=result[4]
        --print("****************************_splitStorageParam ",Lib.v2s(data))
        return data
    end
end

function SkillMovesConfig:getGenSkillDir()
    return "myplugin/"..Define.GenSkillFolder
end

function SkillMovesConfig:getGenMissileDir()
    return "myplugin/"..Define.GenMissileFolder
end

function SkillMovesConfig:_getSkillName(skillId)
    return self:getGenSkillDir().."/"..Define.GenSkillPrefix..tostring(skillId)
end

function SkillMovesConfig:_getDefaultDamageSkillName(skillId)
    return self:getGenSkillDir().."/"..Define.GenDefaultDamageSkillPrefix..tostring(skillId)
end

function SkillMovesConfig:_getMissileName(skillId)
    return self:getGenMissileDir().."/"..Define.GenMissilePrefix..tostring(skillId)
end

function SkillMovesConfig:getDefaultDamageSkillTable(cfg)
    if not cfg or not cfg.genDefaultDamageSkill then
        return
    end
    local data={}
    data.dmgRat=cfg.movesDmg
    data.range=999
    data.type="MeleeAttack"
    data.skillId=cfg.skillId
    return data
end

function SkillMovesConfig:getIsChargeSkillMove(skillMoveId)
    local cfg=self:getNewSkillConfig(skillMoveId)
    return cfg and cfg.storageTimeMin and cfg.storageTimeMax and cfg.storageTimePowerUp
end

function SkillMovesConfig:initNewCfg()
    local config = Lib.read_csv_file(Root.Instance():getGamePath() .. "config/skill_moves2.csv", 2)
    for _, vConfig in pairs(config or {}) do
        if vConfig.skillId ~= "" then
            NewGameSkillMap[vConfig.skillId] = self:initNewSkillByConfig(vConfig)
        end
    end
    --print("------------initNewCfg")
end

---@return NewGameSkill[]
function SkillMovesConfig:getAllNewSkillConfig()
    return NewGameSkillMap
end

---@return NewGameSkill
function SkillMovesConfig:getNewSkillConfig(skillMoveId)
    skillMoveId = tostring(skillMoveId)
    if not NewGameSkillMap[skillMoveId] then
        Lib.logError("Error:Not found the data in skill_moves2.csv, skill id:", skillMoveId)
    end
    return NewGameSkillMap[skillMoveId]
end



SkillMovesConfig:init()
SkillMovesConfig:initNewCfg()

return SkillMovesConfig