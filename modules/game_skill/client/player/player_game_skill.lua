---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by 10184.
--- DateTime: 2020/12/25 15:35
---

local handles = T(Player, "PackageHandlers")
local Player = Player

---@type GameSkillHelper
local GameSkillHelper = T(Lib, "GameSkillHelper")
---@type SkillMovesConfig
local SkillMovesConfig = T(Config, "SkillMovesConfig")
---@type SkillConfig
local SkillConfig = T(Config, "SkillConfig")
---@type AbilitySystem
local AbilitySystem = T(Lib, "AbilitySystem")

local CGInterface = CGame.instance:getShellInterface()

function handles:onEntityFreeGameSkill(packet)
    local entity = World.CurWorld:getEntity(packet.freeObjID)
    if not entity then
        return
    end
    local config = SkillMovesConfig:getSkillConfig(packet.skillId)
    if not config then
        return
    end
    if config.skillClass == "JumpSkill" then
        GameSkillHelper:onEntityDoJumpSkill(entity, packet.skillId)
    else
        local needResult = packet.resultPlayerID == Me.objID
        GameSkillHelper:onEntityFreeSkill(entity, packet.skillId, { needResult = needResult })
    end
end

function Player:clientFreeGameSkill(skillId)
    local config = SkillMovesConfig:getSkillConfig(skillId)
    if not config then
        return
    end
    if config.isClientGoAhead then
        if config.skillClass == "JumpSkill" then
            GameSkillHelper:onEntityDoJumpSkill(self, skillId)
        else
            GameSkillHelper:onEntityFreeSkill(self, skillId, {})
        end
    end
    Me:sendPacket({ pid = "onFreeGameSkill", skillId = skillId })
end

--手机震动
function Player:clientVibratorOnTime(vibratorTime)
    if not vibratorTime or type(vibratorTime) ~= "number" then
        return
    end
    local skillOpenShake = Me:getSkillOpenShake()
    if not skillOpenShake then
        return
    end
    CGInterface:vibratorOnTime(vibratorTime)
end

-- 冲刺技能ID
function Player:getSprintSkillId()
    return 1000001
end

function Player:updateSprintFallGravity()
    if self.isInAirStatus == -1 and self:isInStateType(Define.RoleStatus.SPRINT) then
        if not self.isInSprintGravity then
            self.isInSprintGravity = true
            self:setEntityProp("antiGravity", World.cfg.game_skillSetting.sprintAntiGravity)
            self:setEntityProp("gravity", World.cfg.game_skillSetting.sprintGravity)
        end
    else
        if self.isInSprintGravity then
            self:resetEntityProp("antiGravity")
            if not UI:isOpenWindow("UI/main/gui/win_map_mask") then
                self:resetEntityProp("gravity")
            end
            self.isInSprintGravity = false
        end
    end
end

function Player:updateFallStatus()
    if not self.onGround then
        if self.motion.y > 0 then -- 上升
            if self.isInAirStatus ~= 1 then
                self.isInAirStatus = 1
                self:updateSprintFallGravity()
            end
            self.isInAirStatus = 1
        elseif self.motion.y < 0 then -- 下落
            if self.isInAirStatus ~= -1 then
                self.isInAirStatus = -1
                self:updateSprintFallGravity()
            end
            self.isInAirStatus = -1
        else
            self.isInAirStatus = 0
            self:updateSprintFallGravity()
        end
    end
end

function Player:requestUpdateSkillBuff(skillMoveId, isAdd)
    Me:sendPacket({
        pid = "RequestUpdateSkillBuff",
        skillMoveId = skillMoveId,
        isAdd = isAdd
    })
end

---检测停止移动
function Player:checkAddStopMove(isStopMove)
    if not isStopMove then
        return
    end
    self.stopMove = (self.stopMove or 0) + 1
    if self.stopMove == 1 then
        self:setEntityProp("moveSpeed", 0)
    end
end

---检测恢复移动
function Player:checkSubStopMove(isStopMove)
    if not isStopMove or not self.stopMove then
        return
    end
    self.stopMove = self.stopMove - 1
    if self.stopMove == 0 then
        self:resetEntityProp("moveSpeed")
        self.stopMove = nil
    end
end

function Player:setPlayerBodyRotation(value,priority)
    --print("********************************* Player:setPlayerBodyRotation",value,priority)
    if not self.bodyRotationFlag then
        self.bodyRotationFlag={}
    end
    local pri=priority or Define.BodyRotationPriority.BattleStateLimit
    local flag=false
    self.bodyRotationFlag[pri]=value
    for i = Define.BodyRotationPriorityLen, 1,-1 do
        local v=self.bodyRotationFlag[i]
        --print("************ setPlayerBodyRotation",i,v)
        if v~=nil then
            flag=v
            break
        end
    end
    --print("*********** flag",flag,priority)
    Blockman.instance.gameSettings:setPlayerBodyRotation(flag)
end

function Player:setPlayerGravity(value,priority)
    --print("********************************* Player:setPlayerGravity",value,priority)
    if not self.gravityValue then
        self.gravityValue ={}
    end
    local pri=priority or Define.GravityPriority.SkillActionLimit
    local g
    self.gravityValue[pri]=value
    for i = Define.GravityPriorityLen, 1,-1 do
        local v=self.gravityValue[i]
        --print("************ setPlayerGravity",i,v)
        if v then
            g=v
            break
        end
    end
    if not g then
        self:resetEntityProp("gravity")
    else
        self:setEntityProp("gravity", g)
    end
end

function Player:setCalcYawBySpeedDir(value,priority)
    --print("********************************* Player:setCalcYawBySpeedDir",value,priority)
    if not self.calcYawFlag then
        self.calcYawFlag={}
    end
    local pri=priority or Define.CalcYawPriority.BattleStateLimit
    local flag=1
    self.calcYawFlag[pri]=value
    for i = Define.CalcYawPriorityLen, 1,-1 do
        local v=self.calcYawFlag[i]
        --print("************ setCalcYawBySpeedDir",i,v)
        if v~=nil then
            flag=v
            break
        end
    end
    Me:setProp("calcYawBySpeedDir", flag)
end

function Player:setCtrlLimitByFlyState(value)
    self.ctrlLimitByFlyState=value
end

function Player:getCtrlLimitByFlyState()
    return self.ctrlLimitByFlyState
end

function Player:setSlotSkill(slotList,skillList)
    if skillList and next(skillList)~=nil  and slotList and next(slotList)~=nil  then
        Lib.emitEvent(Event.EVENT_RESET_SKILL,slotList,skillList)
        --self.resetSkillAbility=AbilitySystem:getAbility(self)
    end
end

function Player:resumeSlotSkill()
    Lib.emitEvent(Event.EVENT_RESUME_SKILL)
end

