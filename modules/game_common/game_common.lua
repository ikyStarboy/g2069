---
--- Generated by PluginCreator
--- game_common mainLua
--- DateTime:2023-02-24
---

require "common.define_game_common"
require "common.event_game_common"
require "common.entity_game_common"
require "common.config.player_level_config"
require "common.config.monster_config"
require "common.config.ability_config"
require "common.config.ability_level_config"
require "common.config.attribute_info_config"
require "common.config.item_config"
require "common.config.player_born_config"
require "common.config.reward_box_config"
require "common.config.reward_box_pool_config"
require "common.config.broken_item_config"
require "common.config.shop_config"
require "common.config.safe_region_config"
require "common.report_helper_common"

require "common.config.ability_awake_config"
require "common.target_condition_helper"
require "common.lib_common"

if World.isClient then
    require "client.entity_action_helper"
    require "client.player.player_game_common"
    require "client.player.packet_game_common"
    require "client.entity.entity_game_common"
    require "client.entity.entity_value_func_game_common"
    require "client.gm_game_common"
    require "client.ui_handler"

    Lib.subscribeEvent(Event.EVENT_CLIENT_CHANGE_MAP_START, function()
        if Me.loadWordTimer then
            Me.loadWordTimer()
            Me.loadWordTimer = nil
        end
        UI:openWindow("UI/main/gui/win_map_mask")
    end)

    Lib.subscribeEvent(Event.EVENT_LOAD_WORLD_END, function()
        Me.loadWordTimer = World.Timer(20, function()
            UI:closeWindow("UI/main/gui/win_map_mask")
            Me.loadWordTimer()
            Me.loadWordTimer = nil
        end)
    end)
else
    require "server.player.player_game_common"
    require "server.player.packet_game_common"
    require "server.entity.entity_game_common"
    require "server.entity.entity_value_func_game_common"
    require "server.gm_game_common"
end

local handlers = {}

function handlers.onGameReady()
    if World.cfg.gameCommonSetting and World.cfg.gameCommonSetting.hideDebugInfOndScreen then
        CGame.instance:toggleDebugMessageShown(false)
    end
end

if World.isClient then
    local totalPing = 0
    local curTick = 0
    World.Timer(1, function()
        local ping = CGame.instance:getPing()
        totalPing = totalPing + ping
        curTick = curTick + 1
        if curTick >= 1200 then
            local defaultData = {
                ping = math.ceil(totalPing / 1200)
            }
            Plugins.CallTargetPluginFunc("report", "report", "ping_event", defaultData, Me)
            curTick = 0
            totalPing = 0
        end
        return true
    end)
else
    ---@type TargetConditionHelper
    local TargetConditionHelper = T(Lib, "TargetConditionHelper")

    -- 服务端登陆
    function handlers.OnPlayerLogin(player)
        player:addBuff("myplugin/walk_move_buff")
        player:addBuff("myplugin/normal_idle_buff")
        TargetConditionHelper:cleanPlayerPartRegionData(player)
        player:updateSafeBuffShow()
    end

    function handlers.ENTITY_LEAVE(context)
        local entity = context.obj1
        if not (entity and entity:isValid()) then
            return
        end
        if entity.isPlayer then
            Plugins.CallTargetPluginFunc("report", "report", "player_out", nil, entity)

            local loginTs = entity:getLoginTs()
            local curPlayTime = os.time() - loginTs
            local curPlayHour =  math.floor(curPlayTime/60/60*10)/10 or 0
            local curTotalTime = entity:getNewAllPlayTime() or 0
            entity:setNewAllPlayTime(curPlayHour + curTotalTime)
        end
    end
end

function handlers.PART_CLICKED(context)
    local part = context.part1
    local from = context.from
    Lib.logDebug("----PART_CLICKED--",part.name)
    if not part or not part:isValid() then
        return
    end
    if not from or not from:isValid() or not from.isPlayer then
        return
    end
end

--function handlers.PART_TOUCH_ENTITY_BEGIN(context)
--    local part = context.part1
--    local from = context.obj2
--    if not part or not part:isValid() then
--        return
--    end
--
--    if not from or not from:isValid() then
--        return
--    end
--
--    local partName = part:getProperty("name")
--    if not partName then
--        return
--    end
--end
--
--function handlers.PART_TOUCH_ENTITY_END(context)
--    local part = context.part1
--    local from = context.obj2
--    if not part or not part:isValid() then
--        return
--    end
--    if not from or not from:isValid() then
--        return
--    end
--    local partName = part:getProperty("name")
--    if not partName then
--        return
--    end
--end
--
--function handlers.PART_TOUCH_PART_BEGIN(context)
--    local part1 = context.part1
--    local part2 = context.part2
--    if not part1 or not part1:isValid() then
--        return
--    end
--    if not part2 or not part2:isValid() then
--        return
--    end
--end
--
--function handlers.PART_TOUCH_PART_END(context)
--end


return function(name, ...)
	if type(handlers[name]) ~= "function" then
		return
	end
	return handlers[name](...)
end
