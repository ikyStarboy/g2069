---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by Administrator.
--- DateTime: 2023/3/23 15:32
---

---@type SkillConfig
local SkillConfig = T(Config, "SkillConfig")

local RoleStateBase = require "common.state.base_state"

--- @class SkillChargeState : RoleStateBase
local SkillChargeState = Lib.class("SkillChargeState", RoleStateBase)
---@type SkillMovesConfig
local SkillMovesConfig = T(Config, "SkillMovesConfig")
---@type GameSkillCastHelper
local GameSkillCastHelper = T(Lib,"GameSkillCastHelper")
--- @type SoundManager
local SoundManager = T(Lib, "SoundManager")

local function calStorageTimeRate(entity,skillMoveCfg)
    local rate=0
    if entity.chargeInf.startChargeTime and skillMoveCfg.storageTimePowerUp>=skillMoveCfg.storageTimeMin then
        local chargeTime=math.min(skillMoveCfg.storageTimePowerUp,(World.CurWorld:getTickCount()-entity.chargeInf.startChargeTime)/20)
        rate=(chargeTime-skillMoveCfg.storageTimeMin)/(skillMoveCfg.storageTimePowerUp-skillMoveCfg.storageTimeMin)
    end
    --print("===========================>>> calStorageTimeRate,rate,chargeTimeUse ",rate,(World.CurWorld:getTickCount()-entity.chargeInf.startChargeTime)/20,
    --        skillMoveCfg.storageTimePowerUp,skillMoveCfg.storageTimeMin,skillMoveCfg.storageTimeMax)
    return math.abs(rate)
end

function SkillChargeState:init(type)
    RoleStateBase.init(self, type or Define.RoleStatus.SKILL_CHARGE_STATE)
end

function SkillChargeState:enterState(objID,skillId,skillMoveId,isBurst)
    --print("+++++++++++++++++++++++++++++++++++++++++++++++  SkillChargeState:enterState",objID,skillMoveId)
    local entity=World.CurWorld:getEntity(objID)
    if not entity or not entity:isValid() then
        return
    end
    local skillMoveCfg=SkillMovesConfig:getNewSkillConfig(skillMoveId)
    if not skillMoveCfg then
        return
    end
    RoleStateBase.enterState(self, objID)
    self:stopTimer(entity)
    entity.chargeInf={}

    if not World.isClient then
        ---@type chargeStateData
        local data={}
        data.isCharging=true
        data.canCastSkill=false
        data.skillId=skillId
        data.skillMoveId=skillMoveId
        data.isBurst=isBurst
        entity:setChargeState(data)

        entity.chargeInf.startChargeTime=World.CurWorld:getTickCount()
        local minTime=math.floor(skillMoveCfg.storageTimeMin*20)
        local maxTime=math.floor(skillMoveCfg.storageTimeMax*20)
        entity.chargeInf.minTimer=World.Timer(minTime,function ()
            --print(">>>>>>>>>>>>>>>>> SkillChargeState:enterState minTimer,playerRelease:", skillMoveId, entity.chargeInf.playerRelease)
            if entity:isValid() then
                entity.chargeInf.minTimeFinish=true
                if entity.chargeInf.playerRelease then
                    entity:exitStateType(Define.RoleStatus.SKILL_CHARGE_STATE,true)
                end
            end
        end)
        entity.chargeInf.maxTimer=World.Timer(maxTime,function ()
            --print(">>>>>>>>>>>>>>>>>>>>>>>>>>>> SkillChargeState:enterState maxTimer",skillMoveId)
            if entity:isValid() then
                entity:exitStateType(Define.RoleStatus.SKILL_CHARGE_STATE,true)
            end
        end)
    else
        if skillMoveCfg.storageAction  then
            --entity.preChargeUpAction=entity:getPrevUpperAction()
            entity:updateUpperAction(skillMoveCfg.storageAction, 9999)
            --print(">>>>>>>>>>>>>>>>>> SkillChargeState:enterState entity:getCurChildActor() ",
            --        skillMoveId,entity:getCurChildActor(),skillMoveCfg.storageAction,skillMoveCfg.childActorActionDur)
            if skillMoveCfg.childActorAction and entity:getCurChildActor() then
                entity:playChildBaseAction(entity:getCurChildActor(), skillMoveCfg.storageAction)
                World.Timer(skillMoveCfg.childActorActionDur*20,function ()
                    if entity:isValid() then
                        entity:playChildBaseAction(entity:getCurChildActor(), skillMoveCfg.storageAction.."_hold")
                    end
                end)
            end
        end
        if skillMoveCfg.storageEffect then
            local name=string.format("charge_%d_%d", entity.objID, skillMoveId)
            entity:showEffect(skillMoveCfg.storageEffect,nil,name)
        end
        if skillMoveCfg.storageSound then
            entity.chargeInf.chargeSoundId= SoundManager:playSound(skillMoveCfg.storageSound,entity)
            --print("===================entity.chargeInf.chargeSoundId",entity.chargeInf.chargeSoundId)
        end
        entity:exitStateType(Define.RoleStatus.SKILL_ACTION_STATE)
        local earlyTime=World.cfg.game_skillSetting.storagePowerUpEffectEarly or 0.1
        local delay=math.max(math.floor((skillMoveCfg.storageTimePowerUp-earlyTime)*20),0)
        entity.chargeInf.powerUpTimer=World.Timer(delay,function ()
            if entity:isValid() then
                entity:showEffect(World.cfg.game_skillSetting.storagePowerUpEffect)
                SoundManager:playSound(World.cfg.game_skillSetting.storagePowerUpSound,entity)
            end
        end)
        if entity.objID==Me.objID then
            Me.chargeSkillMoveId=skillMoveId
            local isStopMove=SkillMovesConfig:checkStopMoveOnCharge(skillMoveId)
            Me:checkAddStopMove(isStopMove)
            if isStopMove then
                Blockman.instance.gameSettings.poleForward = 0
                Blockman.instance.gameSettings.poleStrafe = 0
            end
            Me:setPlayerGravity(SkillMovesConfig:checkGravityLimitOnCharge(skillMoveId) and 0 or nil,Define.GravityPriority.SkillActionLimit)
            Me:setPlayerBodyRotation(not SkillMovesConfig:checkRotateLimitOnCharge(skillMoveId),Define.BodyRotationPriority.SkillActionLimit)
            --print("------------------- charge state,entity.checkRotateLimitOnCharge",SkillMovesConfig:checkRotateLimitOnCharge(skillMoveId))
            local cfg=SkillMovesConfig:getNewSkillConfig(skillMoveId)
            if cfg  then
                if cfg.storageMove then
                    if cfg.storageMove.delay > 0 then
                        entity.chargeInf.delayMoveTimer=World.Timer(cfg.storageMove.delay*20,function ()
                            Me:enterStateType(Define.RoleStatus.SKILL_MOVE_STATE,skillMoveId,true)
                        end)
                    else
                        Me:enterStateType(Define.RoleStatus.SKILL_MOVE_STATE,skillMoveId,true)
                    end
                end
                if not cfg.isNormalAttack then
                    GameSkillCastHelper:clearStrategy(Define.GameSkillCastType.Combo)
                end
            end
        end
    end
end

function SkillChargeState:exitState(objID,isCastSkill,skillMoveId)
    --print("================================================================== SkillChargeState:exitState",objID)
    local entity=World.CurWorld:getEntity(objID)
    if not entity or not entity:isValid() or not entity.isPlayer then
        return
    end
    RoleStateBase.exitState(self, objID)
    self:stopTimer(entity)

    ---@type chargeStateData
    local data
    if skillMoveId then
        data={}
        data.skillMoveId=skillMoveId
    else
        data=entity:getChargeState()
    end
    if not data.skillMoveId then
        return
    end
    local skillMoveCfg=SkillMovesConfig:getNewSkillConfig(data.skillMoveId)
    if not skillMoveCfg then
        print("++++++++++++++++++++++++++  SkillChargeState:exitState error",data.skillMoveId,entity.objID)
        return
    end
    if not World.isClient then
        local canFree=false
        if isCastSkill then
            canFree=entity:checkCanFreeSkillMove()
        end
        data.isCharging=false
        data.canCastSkill=canFree
        if canFree then
            data.chargeTimeRate=calStorageTimeRate(entity,skillMoveCfg)
        end
        entity:setChargeState(data)
        --print("---------------------- exitChargeState,canFree,id,isCastSkill:",canFree,data.skillMoveId,isCastSkill)
    else
        if skillMoveCfg.storageAction  then
            entity:updateUpperAction(skillMoveCfg.storageAction, 1)
        end
        if skillMoveCfg.storageEffect then
            local name=string.format("charge_%d_%d", entity.objID, data.skillMoveId)
            entity:delEffect(name)
        end
        if entity.chargeInf and entity.chargeInf.chargeSoundId then
            entity:stopSound(entity.chargeInf.chargeSoundId)
            --print("=================== stop entity.chargeInf.chargeSoundId",entity.chargeInf.chargeSoundId)
        end
        if entity.objID==Me.objID then
            Me:checkSubStopMove(SkillMovesConfig:checkStopMoveOnCharge(Me.chargeSkillMoveId))
            Me:setPlayerGravity(nil,Define.GravityPriority.SkillActionLimit)
            Me:setPlayerBodyRotation(nil,Define.BodyRotationPriority.SkillActionLimit)
            if skillMoveCfg.storageMove then
                Me:exitStateType(Define.RoleStatus.SKILL_MOVE_STATE)
            end
            --print("----------- exit charge ,Me:isInStateType(Define.RoleStatus.BATTLE_STATE)",Me:getActionMappingData().isInBattleState)
        end
        --print("---------------------- exitChargeState,canCastSkill:",data.canCastSkill,data.skillMoveId,data.chargeTimeRate)
        if data.canCastSkill and entity.objID==Me.objID then
            local chargeTimeRate=data.chargeTimeRate or 0
            if data.isBurst then
                Me:enterStateType(Define.RoleStatus.SKILL_BURST_STATE,data.skillId,true,chargeTimeRate)
            else
                local packet={}
                packet.chargeTimeRate=chargeTimeRate
                Skill.Cast(skillMoveCfg.skillName,packet)
                Lib.emitEvent(Event.EventButtonCDTimer,data.skillId)
                local config = SkillConfig:getSkillConfig(data.skillId)
                Me:requestCostMp(data.skillId)
                --print("+++++++++++++++++  yaw",entity:getRotationYaw(),entity:getBodyYaw())
                ---空中蓄力时转向，模型不会旋转，释放时手动设置，否则前后端子弹方向不一致
                entity:setBodyYaw(entity:getRotationYaw())
            end
        end
    end
end

function SkillChargeState:stopTimer(entity)
    if entity and entity.chargeInf then
        if entity.chargeInf.minTimer then
            entity.chargeInf.minTimer()
            entity.chargeInf.minTimer=nil
        end
        if entity.chargeInf.maxTimer then
            entity.chargeInf.maxTimer()
            entity.chargeInf.maxTimer=nil
        end
        if entity.chargeInf.delayMoveTimer then
            entity.chargeInf.delayMoveTimer()
            entity.chargeInf.delayMoveTimer=nil
        end
        if entity.chargeInf.powerUpTimer then
            entity.chargeInf.powerUpTimer()
            entity.chargeInf.powerUpTimer=nil
        end
    end
end


return SkillChargeState