---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by Administrator.
--- DateTime: 2023/3/23 15:32
---

local RoleStateBase = require "common.state.base_state"

--- @class SkillMoveState : RoleStateBase
local SkillMoveState = Lib.class("SkillMoveState", RoleStateBase)
---@type SkillMovesConfig
local SkillMovesConfig = T(Config, "SkillMovesConfig")

---@param moveCfg NewGameSkill
local function calMoveUpByCharge(moveCfg,chargeTimeRate)
    local speedUp=0
    if not chargeTimeRate or chargeTimeRate == 0  or not moveCfg then
        --print("---------------------- calMoveUpByCharge no speedUp")
        return speedUp
    end
    if moveCfg.storageParam then
        speedUp=moveCfg.storageParam.move*chargeTimeRate
       --print("---------------------- calMoveUpByCharge speedUp,chargeTimeRate,hitBack",speedUp,chargeTimeRate,moveCfg.storageParam.move)
    else
        --print("---------------------- calMoveUpByCharge no speedUp")
    end
    return speedUp
end

function SkillMoveState:init(type)
    RoleStateBase.init(self, type or Define.RoleStatus.SKILL_MOVE_STATE)
end

local forwardDirectionX = 0
local forwardDirectionY = 0
local forwardDirectionZ = 1
local function applyDirection(moveInf,entity)
    if not moveInf then
        return
    end
    local currentYawRad
    if World.isClient then
        currentYawRad = math.rad(-entity:getBodyYaw())
    else
        currentYawRad = math.rad(-entity:getRotationYaw())
    end
    local pitch=math.rad(moveInf.pitch)
    local y=math.sin(pitch)
    local xz=math.cos(pitch)
    local x, z = math.sin(currentYawRad)*xz, math.cos(currentYawRad)*xz
    forwardDirectionX = x
    forwardDirectionZ = z
    forwardDirectionY = y
end

function SkillMoveState:enterState(objID, skillMoveId,isCharge,chargeTimeRate)
    RoleStateBase.enterState(self, objID)
    local entity=World.CurWorld:getEntity(objID)
    --if not entity or not entity:isValid() or not skillMoveId or not World.isClient or entity.objID~=Me.objID then
    --    return
    --end
    if not entity or not entity:isValid() or not skillMoveId then
        return
    end
    local cfg=SkillMovesConfig:getNewSkillConfig(skillMoveId)
    if not cfg then
        return
    end
    local moveInf=isCharge and cfg.storageMove or cfg.move
    if not moveInf then
        return
    end

    self:stopTimer(entity)
    local socket
    if World.isClient then
        socket = require("socket")
        entity.skillMoveStateBegin=socket.gettime()
    else
        entity.skillMoveStateBeginTick=World.CurWorld:getTickCount()
    end
    --local socket = require("socket")
    --entity.skillMoveStateBegin=socket.gettime()
    --entity.skillMoveStateBeginTick=World.CurWorld:getTickCount()
    --print(">>>>>>>>>>>>>>>>>>>>>>>> SkillMoveState:enterState,objID, skillMoveId,duration,isCharge",objID, skillMoveId,moveInf.duration,isCharge,chargeTimeRate)
    local forwardSpeed = moveInf.speed
    local speedUp=calMoveUpByCharge(cfg,chargeTimeRate)
    forwardSpeed=forwardSpeed*(1+speedUp)
    applyDirection(moveInf,entity)
    --Me:setSprintMotion({forwardDirectionX, forwardDirectionY, forwardDirectionZ})
    local counter=0
    entity.skillMoveStateTimer = World.LightTimer("SprintSkillHelper:enterSprintSkillState", 1, function()
        if forwardSpeed < World.cfg.game_skillSetting.maxSprintSpeed then
            forwardSpeed = math.max(0,forwardSpeed +  moveInf.acc)
        end
        counter=counter+1
        --print("------------------------ skillMoveStateTimer ,counter,forwardSpeed",counter,forwardSpeed)
        entity:moveUntilCollide(Lib.v3(0, 0.2, 0) * forwardSpeed)
        entity:moveUntilCollide(Lib.v3(forwardDirectionX, forwardDirectionY, forwardDirectionZ) * forwardSpeed)
        entity:moveUntilCollide(Lib.v3(0, -0.2, 0) * forwardSpeed)
        local isEnd
        if World.isClient then
            isEnd=socket.gettime()-entity.skillMoveStateBegin>=moveInf.duration
        else
            isEnd=World.CurWorld:getTickCount()-entity.skillMoveStateBeginTick>=math.ceil(moveInf.duration*20)
        end
        if isEnd then
            if entity:isValid() then
                entity:exitStateType(Define.RoleStatus.SKILL_MOVE_STATE)
            end
            return false
        else
            return true
        end
    end)

    if World.isClient and entity.objID == Me.objID then
        entity:setPlayerGravity(0,Define.GravityPriority.MoveLimit)
    end
end

function SkillMoveState:exitState(objID)
    RoleStateBase.exitState(self, objID)
    local entity=World.CurWorld:getEntity(objID)
    --if not entity or not entity:isValid() or not World.isClient or entity.objID~=Me.objID then
    --    return
    --end
    if not entity or not entity:isValid() then
        return
    end
    self:stopTimer(entity)
    if World.isClient and entity.objID == Me.objID then
        entity:setPlayerGravity(nil,Define.GravityPriority.MoveLimit)
    end
    --print("================================================================== SkillMoveState:exitState",objID)
end

function SkillMoveState:stopTimer(entity)
    if entity.skillMoveStateTimer then
        entity.skillMoveStateTimer()
        entity.skillMoveStateTimer=nil
    end
end

return SkillMoveState