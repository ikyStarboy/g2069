---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by Administrator.
--- DateTime: 2023/3/23 15:32
---

local RoleStateBase = require "common.state.base_state"

--- @class RoleBlowAwayState : RoleStateBase
local RoleBlowAwayState = Lib.class("RoleBlowAwayState", RoleStateBase)
---@type SkillMovesConfig
local SkillMovesConfig = T(Config, "SkillMovesConfig")

function RoleBlowAwayState:init(type)
    RoleStateBase.init(self, type or Define.RoleStatus.BLOW_AWAY)
    self.blowAwayMotion = {}
end

---@param moveCfg NewGameSkill
local function calUpByCharge(moveCfg,chargeTimeRate)
    if not chargeTimeRate or chargeTimeRate == 0  or not moveCfg then
        return
    end
    local speedUp=0
    if moveCfg.storageParam then
        speedUp=moveCfg.storageParam.hitBack*chargeTimeRate
        --print("---------------------- calUpByCharge speedUp,chargeTimeRate,hitBack",speedUp,chargeTimeRate,moveCfg.storageParam.hitBack)
    else
        --print("---------------------- calUpByCharge no speedUp")
    end
    moveCfg.hitBack.Vx = moveCfg.hitBack.Vx*(1+speedUp)
    moveCfg.hitBack.Vy = moveCfg.hitBack.Vy*(1+speedUp)
end

function RoleBlowAwayState:enterState(objID, attacker,param)
    --print("---------------------RoleBlowAwayState:enterState,objID",objID,param.skillId,attacker.isPlayer)
    RoleStateBase.enterState(self, objID)
    local entity=World.CurWorld:getEntity(objID)
    if not entity or not entity:isValid() then
        return
    end

    if World.isClient then
        if not entity.isPlayer or entity.objID~=Me.objID then
            return
        end
    end
    
    local moveCfg=Lib.copy( SkillMovesConfig:getNewSkillConfig(param.skillId))
    if not moveCfg or not moveCfg.hitBack or (moveCfg.hitBack.Vx == 0 and moveCfg.hitBack.Vy== 0) then
        return
    end
    calUpByCharge(moveCfg,param.exParam.packet.chargeTimeRate)
    local dirV
    if moveCfg.hitBack.dir == Define.GameSkillHitBackDir.MissileDir then
        dirV = Lib.tov3(param.exParam.packet.motion)
    elseif moveCfg.hitBack.dir == Define.GameSkillHitBackDir.MissileToTarget then
        dirV = Lib.tov3(entity:getPosition()) - Lib.tov3(param.exParam.packet.startPos)
    elseif( moveCfg.hitBack.dir == Define.GameSkillHitBackDir.AttackerDir) and attacker and attacker:isValid() then
        --local sprintMotion=attacker:getSprintMotion()
        --dirV = Lib.tov3({x=sprintMotion[1] or 0,y=sprintMotion[2] or 0,z=sprintMotion[3] or 0})
        local yaw=math.rad(-attacker:getRotationYaw())
        dirV=Lib.tov3({x=math.sin(yaw),y= 0,z=math.cos(yaw)})
    elseif attacker and attacker:isValid() then
        dirV = Lib.tov3(entity:getPosition()) - Lib.tov3(attacker:getPosition())
    end
    if not dirV then
        return
    end
    dirV:normalize()

    entity.blowAwayInf={}
    entity.blowAwayInf.Vy=moveCfg.hitBack.Vy
    entity.blowAwayInf.groundHitBack =entity.blowAwayInf.Vy==0 or entity.blowAwayInf.Vy==nil
    local motionRate=1
    if entity:isMonster() and not World.isClient and entity.blowAwayInf.groundHitBack then
        motionRate=entity:cfg().aiFixSpeedRate or 1
        moveCfg.hitBack.Vx=moveCfg.hitBack.Vx*motionRate
    end
    entity.blowAwayInf.Vx=dirV.x*moveCfg.hitBack.Vx
    entity.blowAwayInf.Vz=dirV.z*moveCfg.hitBack.Vx
    entity.blowAwayInf.Ax=moveCfg.hitBack.Ax
    local speedLimit=math.sqrt(moveCfg.hitBack.Vx*moveCfg.hitBack.Vx+moveCfg.hitBack.Vy*moveCfg.hitBack.Vy)
    entity:setEntityProp("moveSpeed",speedLimit)
    local gravity=math.max(0.1,entity:prop("gravity"))
    if entity.blowAwayInf.groundHitBack then
        entity:setEntityProp("moveAcc",entity.blowAwayInf.Ax)
        entity.blowAwayInf.counter =math.ceil(math.abs(moveCfg.hitBack.Vx)/math.max(math.abs(entity.blowAwayInf.Ax*motionRate),0.01))
    else
        entity:setEntityProp("moveAcc",0)
        entity.blowAwayInf.counter =math.ceil(math.abs(moveCfg.hitBack.Vy)/math.abs(gravity))*2
    end

    if not World.isClient then
        self:stopTimer(entity)

        if entity.calcYawTimer then
            entity.calcYawTimer()
            entity.calcYawTimer = nil
        end

        local motion=entity.motion
        if not self.blowAwayMotion[objID] then
            self.blowAwayMotion[objID] = Lib.copyTable1(entity.motion)
        end
       
        motion.x = entity.blowAwayInf.Vx
        motion.z = entity.blowAwayInf.Vz
        motion.y = entity.blowAwayInf.Vy
        entity.motion=motion
        entity:tryMove(Vector3.Zero,Vector3.Zero)
        entity:setPosition(entity:getPosition())
        if entity:isMonster() then
            local control = entity:getAIControl()
            control:setPauseState(true,Define.PauseStatePriority.BlowAway)
            control:setTargetPos()
            entity:setProp("calcYawBySpeedDir", 0)
        end

        --print("==================counter,speedLimit", entity.blowAwayInf.counter,speedLimit,entity.blowAwayInf.Vx,entity.blowAwayInf.Vy,entity.blowAwayInf.Vz)
        entity.blowAwayTimer=World.Timer(1,function ()
            --print("motion=========", entity.blowAwayInf.counter, entity:getEntityProp("moveAcc"),entity.motion.x,entity.motion.y,entity.motion.z)
            if not entity or not entity:isValid() then
                return false
            end
            entity:tryMove(Vector3.Zero,Vector3.Zero)
            entity:setPosition(entity:getPosition())
            if not entity.blowAwayInf.groundHitBack and entity.onGround then
                --print("-----------------------------onGround", entity.blowAwayInf.counter)
                entity:exitStateType(Define.RoleStatus.BLOW_AWAY, attacker)
                return false
            end
            entity.blowAwayInf.counter = entity.blowAwayInf.counter -1
            if entity.blowAwayInf.counter <=0 then
                --print("-----------------------------counter<=0")
                entity:exitStateType(Define.RoleStatus.BLOW_AWAY, attacker)
                return false
            end
            return true
        end)
    else
        entity:setPlayerBeBlowAway(1)
        self:stopTimer(entity)
        local motion = entity.motion
        motion.x = motion.x+ entity.blowAwayInf.Vx
        motion.z = motion.z+ entity.blowAwayInf.Vz
        motion.y = motion.y+ entity.blowAwayInf.Vy
        entity.motion = motion
        --print("==================counter,speedLimit", entity.blowAwayInf.counter,speedLimit,entity:getPlayerBeBlowAway())
        entity.blowAwayTimer=World.Timer(1,function ()
            --print("motion=========", entity.blowAwayInf.counter, entity.motion.x,entity.motion.y,entity.motion.z,entity:getPlayerBeBlowAway())
            if not entity or not entity:isValid() then
                return false
            end
            if not entity.blowAwayInf.groundHitBack and entity.onGround then
                --print("-----------------------------onGround", entity.blowAwayInf.counter)
                entity:exitStateType(Define.RoleStatus.BLOW_AWAY)
                return false
            end
            entity.blowAwayInf.counter = entity.blowAwayInf.counter -1
            if entity.blowAwayInf.counter <=0 then
                --print("-----------------------------counter<=0")
                entity:exitStateType(Define.RoleStatus.BLOW_AWAY)
                return false
            end
            return true
        end)
    end
end

function RoleBlowAwayState:exitState(objID, attacker)
    --print("---------------------RoleBlowAwayState:exitState,objID",objID)
    RoleStateBase.exitState(self, objID)
    local entity=World.CurWorld:getEntity(objID)
    if  not entity or not entity:isValid() then
        return
    end
    self:stopTimer(entity)
    entity:resetEntityProp("moveAcc")
    entity:resetEntityProp("moveSpeed")
    if World.isClient  then
        if entity.isPlayer and entity.objID==Me.objID then
            entity.playerBeBlowAwayTimer = World.Timer(20*1,function ()
                if entity:isValid() then
                    entity:setPlayerBeBlowAway(0)
                end
            end)
        end
    else
        if self.blowAwayMotion[objID] then
            entity.motion = Lib.copyTable1(self.blowAwayMotion[objID])
            self.blowAwayMotion[objID] = nil
        end

        if entity:isMonster() and (not entity:isInStateType(Define.RoleStatus.DEAD)) then
            local control = entity:getAIControl()
            control:setPauseState(nil,Define.PauseStatePriority.BlowAway)

            if attacker and attacker:isValid() then
                entity:face2Pos(attacker:getPosition())
            end
            entity.calcYawTimer = World.Timer(10, function()
                if entity and entity:isValid() then
                    entity:setProp("calcYawBySpeedDir", 1)
                    if attacker and attacker:isValid() then
                        entity:face2Pos(attacker:getPosition())
                    end
                    entity.calcYawTimer()
                    entity.calcYawTimer = nil
                end
                return false
            end)
        end
    end
end

function RoleBlowAwayState:stopTimer(entity)
    if entity and entity.blowAwayTimer then
        entity.blowAwayTimer()
        entity.blowAwayTimer=nil
    end
    if entity and entity.playerBeBlowAwayTimer then
        entity.playerBeBlowAwayTimer()
        entity.playerBeBlowAwayTimer=nil
    end
end

return RoleBlowAwayState